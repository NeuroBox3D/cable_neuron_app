------------------------------------------------------------------
-- This file contains utilities for cable equation simulations. --
------------------------------------------------------------------
ug_load_script("ug_util.lua")
ug_load_script("util/load_balancing_util.lua")

function setup_problem_ug4(
	cableDisc,		-- object of type CableEquation
	gridName,		-- string containing the network or neuron file
	neededSubset,	-- subsets necessary for correct working of the model represented in cableDisc (optional)
	imbFactor,		-- allowed imbalance when distributing the grid (optional)
	verbose			-- whether output is to be verbose (optional)
)
	-- check mandatory args
	if gridName == nil then print("No grid name given to setup routine. Aborting."); exit(); end
	if cableDisc == nil then
		print("No cable equation discretization object given to setup routine. Aborting.");
		exit();
	end
	
	-- check optional args
	neededSubsets = neededSubsets or {}
	imbFactor = imbFactor or 1.05
	if verbose == nil then verbose = true end
	
	-- create domain for calculation
	local dom = util.CreateDomain(gridName, 0, neededSubsets)
	
	-- distribute network to processes automatically
	balancer.partitioner	= "parmetis"
	balancer.firstDistLvl	= -1
	balancer.redistSteps	= 0
	balancer.imbalanceFactor = imbFactor
	balancer.staticProcHierarchy = true
	balancer.ParseParameters()
	
	local loadBalancer = balancer.CreateLoadBalancer(dom)
	if loadBalancer ~= nil then
		loadBalancer:enable_vertical_interface_creation(false)
		balancer.RefineAndRebalanceDomain(dom, 0, loadBalancer)
		loadBalancer:estimate_distribution_quality()
		loadBalancer:print_quality_records()
	end
	
	-- create approximation space for unknown function v (membrane potential)
	-- Lagrange 1 space contains all functions that are continuous and
	-- (piece-wise) linear on each edge of the geometry
	local approxSpace = ApproximationSpace(dom)
	approxSpace:add_fct("v", "Lagrange", 1)
	
	-- gating functions for HH-Fluxes
	approxSpace:init_levels();
	approxSpace:init_surfaces();
	approxSpace:init_top_surface();
	
	-- impose order on the unknowns that will ensure linear solver to be fast
	order_cuthillmckee(approxSpace);
	
	local domainDisc = DomainDiscretization(approxSpace)
	domainDisc:add(cableDisc)
	
	-- speeding up the assembling
	-- UG4 solvers are general purpose solvers, but we have a very special case here
	-- which we can benefit from in terms of solver speed
	local assemblingTuner = domainDisc:ass_tuner()
	-- do not forget to keep a copy of cableAssTuner in output! otherwise strange behavior when it gets destroyed!
	local cableAssemblingTuner = CableAssTuner(domainDisc, approxSpace)
	cableAssemblingTuner:remove_ghosts_from_assembling_iterator()
	
	-- time discretization
	local timeDisc = ThetaTimeStep(domainDisc)
	timeDisc:set_theta(1.0)	-- this is the backwards Euler scheme
	
	-- create instationary linear operator
	local linOp = AssembledLinearOperator(timeDisc)
	
	-- solver setup
	local convCheck = ConvCheck(1, 1e-30, 1e-12, verbose)
	local ilu = ILU()
	local solver = LinearSolver()
	solver:set_preconditioner(ilu)
	solver:set_convergence_check(convCheck)
	
	-- prepare output table
	local ugEnv = {}
	ugEnv.cableDisc = cableDisc
	ugEnv.approxSpace = approxSpace
	ugEnv.assemblingTuner = assemblingTuner
	ugEnv.cableAssemblingTuner = cableAssemblingTuner
	ugEnv.timeDisc = timeDisc
	ugEnv.linOp = linOp
	ugEnv.solver = solver
	ugEnv.ilu = ilu
	
	return ugEnv
end



function run_simulation(
	ugEnv,		-- ug environment generated by setup_problem_ug4()
	simParams	-- simulation params:
				--   v_init: initial membrane potential in mV (optional, default: -65.0)
				--   startTime: initial time in ms (optional, default: 0.0)
				--   endtTime: end time in ms (optional, default: 1.0)
				--   dt: integration step in ms (optional, default: 0.02)
				--   generateVTKOutput: whether to output vtk files (optional, default: false)
				--   vtkFolder: folder to write vtk output to (required iff vtk output enabled)
				--   plotStep: steps at which to output vtk data (optional, default: dt)
)
	-- check mandatory args
	if ugEnv == nil then
		print("No UG4 environment given to run routine. Aborting.");
		exit();
	end
	
	if simParams == nil then
		print("No simulation params given to run routine. Aborting.");
		exit();
	end

	-- check ug env
	if ugEnv.cableDisc == nil then print("No cable discretization in ugEnv. Aborting."); exit(); end
	if ugEnv.approxSpace == nil then print("No approximation space in ugEnv. Aborting."); exit(); end
	if ugEnv.assemblingTuner == nil then print("No assembling tuner in ugEnv. Aborting."); exit(); end
	if ugEnv.timeDisc == nil then print("No time discretization in ugEnv. Aborting."); exit(); end
	if ugEnv.linOp == nil then print("No linear operator in ugEnv. Aborting."); exit(); end
	if ugEnv.solver == nil then print("No solver in ugEnv. Aborting."); exit(); end
	if ugEnv.ilu == nil then print("No ILU in ugEnv. Aborting."); exit(); end
	
	local cableDisc = ugEnv.cableDisc
	local approxSpace = ugEnv.approxSpace
	local assemblingTuner = ugEnv.assemblingTuner
	local timeDisc = ugEnv.timeDisc
	local linOp = ugEnv.linOp
	local solver = ugEnv.solver
	local ilu = ugEnv.ilu

	-- check simulation params
	local v_init = simParams.v_init or -65.0
	local startTime = simParams.startTime or 0.0
	local endTime = simParams.endTime or 1.0
	local dt = simParams.dt or 0.02
	local generateVTKOutput = simParams.generateVTKOutput or false
	local vtkFolder = simParams.vtkFolder
	if generateVTKOutput == true and vtkFolder == nil then
		print("VTK output option chosen, but no vtkFolder supplied. Aborting.")
		exit()
	end
	local plotStep = simParams.plotStep or dt
	-- todo: check if plot step is a multiple of dt
	

	-------------------
	-- time stepping --
	-------------------
	local time = startTime

	-- init solution
	local u = GridFunction(approxSpace)	-- the solution vector
	local b = GridFunction(approxSpace)	-- the right hand side vector
	u:set(0.0) 						-- ensures the correct parallel state of the solution
	Interpolate(v_init, u, "v")		-- initial solution is equilibrium state
	
	-- write start solution
	if generateVTKoutput == true then 
		out = VTKOutput()
		out:print_subsets(vtkFolder .."/somatic_signals", u, "Soma", 0, time)
	end
	
	-- store start solution in vector of old solutions
	local uOld = u:clone()
	local solTimeSeries = SolutionTimeSeries()
	solTimeSeries:push(uOld, time)
	
	-- parameters for adaptive time stepping
	local curr_dt = dt
	local dtred = 2
	local lv = 0
	local lvl_step_counter = {}
	lvl_step_counter[lv] = 0
	local dtChanged
	
	-- begin the time loop
	while endTime-time > 0.001*curr_dt do
		-- setup time Disc for old solutions and timestep
		timeDisc:prepare_step(solTimeSeries, curr_dt)
		
		-- reduce time step if necessary
		-- (this needs to be done AFTER prepare_step as channels are updated there)
		dtChanged = false
		local cfl = cableDisc:estimate_cfl_cond(solTimeSeries:latest())
		while (curr_dt > cfl) do
			curr_dt = curr_dt/dtred
			lv = lv + 1
			lvl_step_counter[lv] = 0
			dtChanged = true
		end
		
		-- increase time step if possible (and if time is aligned with new bigger step size)
		while curr_dt*dtred < cfl and lv > 0 and lvl_step_counter[lv] % (dtred) == 0 do
			curr_dt = curr_dt*dtred;
			lv = lv - 1
			lvl_step_counter[lv] = lvl_step_counter[lv] + lvl_step_counter[lv+1]/dtred
			lvl_step_counter[lv+1] = 0
			dtChanged = true
		end
		
		print("++++++ POINT IN TIME " .. math.floor((time+curr_dt)/curr_dt+0.5)*curr_dt .. " BEGIN ++++++")
		
		-- prepare again with new time step size (if changed)
		if dtChanged == true then
			timeDisc:prepare_step(solTimeSeries, curr_dt)
		end
		
		-- assemble linear problem
		local matrixIsConst = time ~= startTime and dtChanged == false
		assemblingTuner:set_matrix_is_const(matrixIsConst)
		if AssembleLinearOperatorRhsAndSolution(linOp, u, b) == false then 
			print("Could not assemble operator"); exit(); 
		end
			
		-- apply linear solver
		ilu:set_disable_preprocessing(matrixIsConst)
		if ApplyLinearSolver(linOp, u, b, solver) == false then
			print("Could not apply linear solver."); exit(); 
		end
		
		-- update to new time
		time = solTimeSeries:time(0) + curr_dt
		lvl_step_counter[lv] = lvl_step_counter[lv] + 1
		
		-- vtk output
		if generateVTKoutput == true then 
			if math.abs(time/plotStep - math.floor(time/plotStep+0.5)) < 1e-5 then 
				out:print_subsets(vtkFolder .."/somatic_signals", u, "Soma", math.floor(time/plotStep+0.5), time)
			end
		end
		
		-- update time series (re-use memory)
		local oldestSol = solTimeSeries:oldest()
		VecScaleAssign(oldestSol, 1.0, u)
		solTimeSeries:push_discard_oldest(oldestSol, time)
		
		print("++++++ POINT IN TIME " .. math.floor((time)/curr_dt+0.5)*curr_dt .. "  END ++++++")
	end
	
	-- end timeseries, produce gathering file
	if generateVTKoutput == true then 
		out:write_time_pvd(vtkFolder .."/somatic_signals", u)
	end

end



